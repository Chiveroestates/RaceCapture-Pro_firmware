   1              	# 1 "startup_SAM7S.S"
   2              	# 1 "<built-in>"
   1              	/***********************************************************************/
   0              	
   0              	
   2              	/*                                                                     */
   3              	/*  startup_SAM7S.S:  Startup file for Atmel AT91SAM7S device series   */
   4              	/*                                                                     */
   5              	/***********************************************************************/
   6              	/*  ported to arm-elf-gcc / WinARM by Martin Thomas, KL, .de           */
   7              	/*  <eversmith@heizung-thomas.de>                                      */
   8              	/*  modifications Copyright Martin Thomas 2005                         */
   9              	/*                                                                     */
  10              	/*  Based on a file that has been a part of the uVision/ARM            */
  11              	/*  development tools, Copyright KEIL ELEKTRONIK GmbH 2002-2004        */
  12              	/***********************************************************************/
  13              	
  14              	/* 
  15              	  Modifications by Martin Thomas:
  16              	  - added handling of execption vectors in RAM ("ramfunc")
  17              	  - added options to remap the interrupt vectors to RAM
  18              	    (see makefile for switch-option)
  19              	  - replaced all ";" and "#" for comments with // or / *  * /
  20              	  - added C++ ctor handling
  21              	  - .text in RAM for debugging (RAM_RUN)
  22              	*/
  23              	
  24              	
  25              	// mt: this file should not be used with the Configuration Wizard
  26              	// since a lot of changes have been done for the WinARM/gcc example
  27              	/* 
  28              	//*** <<< Use Configuration Wizard in Context Menu >>> ***
  29              	*/
  30              	
  31              	
  32              	
  33              	// *** Startup Code (executed after Reset) ***
  34              	
  35              	
  36              	// Standard definitions of Mode bits and Interrupt (I & F) flags in PSRs
  37              	
  38              	        .equ    Mode_USR,       0x10
  39              	        .equ    Mode_FIQ,       0x11
  40              	        .equ    Mode_IRQ,       0x12
  41              	        .equ    Mode_SVC,       0x13
  42              	        .equ    Mode_ABT,       0x17
  43              	        .equ    Mode_UND,       0x1B
  44              	        .equ    Mode_SYS,       0x1F
  45              	
  46              	        .equ    I_Bit,          0x80    /* when I bit is set, IRQ is disabled */
  47              	        .equ    F_Bit,          0x40    /* when F bit is set, FIQ is disabled */
  48              	
  49              	
  50              	// Internal Memory Base Addresses
  51              	        .equ    FLASH_BASE,     0x00100000   
  52              	        .equ    RAM_BASE,       0x00200000
  53              	
  54              	
  55              	/*
  56              	// <h> Stack Configuration
  57              	//   <o>  Top of Stack Address  <0x0-0xFFFFFFFF:4>
  58              	//   <h>  Stack Sizes (in Bytes)
  59              	//     <o1> Undefined Mode      <0x0-0xFFFFFFFF:4>
  60              	//     <o2> Supervisor Mode     <0x0-0xFFFFFFFF:4>
  61              	//     <o3> Abort Mode          <0x0-0xFFFFFFFF:4>
  62              	//     <o4> Fast Interrupt Mode <0x0-0xFFFFFFFF:4>
  63              	//     <o5> Interrupt Mode      <0x0-0xFFFFFFFF:4>
  64              	//     <o6> User/System Mode    <0x0-0xFFFFFFFF:4>
  65              	//   </h>
  66              	// </h>
  67              	*/
  68              	        .equ    Top_Stack,      0x00204000  /* AT91SAM7S64  */
  69              	/*        .equ    Top_Stack,      0x00210000  /* AT91SAM7S256 */
  70              	        .equ    UND_Stack_Size, 0x00000004
  71              	        .equ    SVC_Stack_Size, 0x00000100
  72              	        .equ    ABT_Stack_Size, 0x00000004
  73              	        .equ    FIQ_Stack_Size, 0x00000004
  74              	        .equ    IRQ_Stack_Size, 0x00000100
  75              	        .equ    USR_Stack_Size, 0x00000400
  76              	
  77              	
  78              	// Embedded Flash Controller (EFC) definitions
  79              	        .equ    EFC_BASE,       0xFFFFFF00  /* EFC Base Address */
  80              	        .equ    EFC_FMR,        0x60        /* EFC_FMR Offset */
  81              	
  82              	/*
  83              	// <e> Embedded Flash Controller (EFC)
  84              	//   <o1.16..23> FMCN: Flash Microsecond Cycle Number <0-255>
  85              	//               <i> Number of Master Clock Cycles in 1us
  86              	//   <o1.8..9>   FWS: Flash Wait State
  87              	//               <0=> Read: 1 cycle / Write: 2 cycles
  88              	//               <1=> Read: 2 cycle / Write: 3 cycles
  89              	//               <2=> Read: 3 cycle / Write: 4 cycles
  90              	//               <3=> Read: 4 cycle / Write: 4 cycles
  91              	// </e>
  92              	*/
  93              	        .equ    EFC_SETUP,      1
  94              	        .equ    EFC_FMR_Val,    0x00320100
  95              	
  96              	
  97              	// Watchdog Timer (WDT) definitions
  98              	        .equ    WDT_BASE,       0xFFFFFD40  /* WDT Base Address */
  99              	        .equ    WDT_MR,         0x04        /* WDT_MR Offset */
 100              	
 101              	/*
 102              	// <e> Watchdog Timer (WDT)
 103              	//   <o1.0..11>  WDV: Watchdog Counter Value <0-4095>
 104              	//   <o1.16..27> WDD: Watchdog Delta Value <0-4095>
 105              	//   <o1.12>     WDFIEN: Watchdog Fault Interrupt Enable
 106              	//   <o1.13>     WDRSTEN: Watchdog Reset Enable
 107              	//   <o1.14>     WDRPROC: Watchdog Reset Processor
 108              	//   <o1.28>     WDDBGHLT: Watchdog Debug Halt
 109              	//   <o1.29>     WDIDLEHLT: Watchdog Idle Halt
 110              	//   <o1.15>     WDDIS: Watchdog Disable
 111              	// </e>
 112              	*/
 113              	        .equ    WDT_SETUP,      1
 114              	        .equ    WDT_MR_Val,     0x00008000
 115              	
 116              	
 117              	// Power Mangement Controller (PMC) definitions
 118              	        .equ    PMC_BASE,       0xFFFFFC00  /* PMC Base Address */
 119              	        .equ    PMC_MOR,        0x20        /* PMC_MOR Offset */
 120              	        .equ    PMC_MCFR,       0x24        /* PMC_MCFR Offset */
 121              	        .equ    PMC_PLLR,       0x2C        /* PMC_PLLR Offset */
 122              	        .equ    PMC_MCKR,       0x30        /* PMC_MCKR Offset */
 123              	        .equ    PMC_SR,         0x68        /* PMC_SR Offset */
 124              	        .equ    PMC_MOSCEN,     (1<<0)      /* Main Oscillator Enable */
 125              	        .equ    PMC_OSCBYPASS,  (1<<1)      /* Main Oscillator Bypass */
 126              	        .equ    PMC_OSCOUNT,    (0xFF<<8)   /* Main OScillator Start-up Time */
 127              	        .equ    PMC_DIV,        (0xFF<<0)   /* PLL Divider */
 128              	        .equ    PMC_PLLCOUNT,   (0x3F<<8)   /* PLL Lock Counter */
 129              	        .equ    PMC_OUT,        (0x03<<14)  /* PLL Clock Frequency Range */
 130              	        .equ    PMC_MUL,        (0x7FF<<16) /* PLL Multiplier */
 131              	        .equ    PMC_USBDIV,     (0x03<<28)  /* USB Clock Divider */
 132              	        .equ    PMC_CSS,        (3<<0)      /* Clock Source Selection */
 133              	        .equ    PMC_PRES,       (7<<2)      /* Prescaler Selection */
 134              	        .equ    PMC_MOSCS,      (1<<0)      /* Main Oscillator Stable */
 135              	        .equ    PMC_LOCK,       (1<<2)      /* PLL Lock Status */
 136              	
 137              	/*
 138              	// <e> Power Mangement Controller (PMC)
 139              	//   <h> Main Oscillator
 140              	//     <o1.0>      MOSCEN: Main Oscillator Enable
 141              	//     <o1.1>      OSCBYPASS: Oscillator Bypass
 142              	//     <o1.8..15>  OSCCOUNT: Main Oscillator Startup Time <0-255>
 143              	//   </h>
 144              	//   <h> Phase Locked Loop (PLL)
 145              	//     <o2.0..7>   DIV: PLL Divider <0-255>
 146              	//     <o2.16..26> MUL: PLL Multiplier <0-2047>
 147              	//                 <i> PLL Output is multiplied by MUL+1
 148              	//     <o2.14..15> OUT: PLL Clock Frequency Range
 149              	//                 <0=> 80..160MHz  <1=> Reserved
 150              	//                 <2=> 150..220MHz <3=> Reserved
 151              	//     <o2.8..13>  PLLCOUNT: PLL Lock Counter <0-63>
 152              	//     <o2.28..29> USBDIV: USB Clock Divider
 153              	//                 <0=> None  <1=> 2  <2=> 4  <3=> Reserved
 154              	//   </h>
 155              	//   <o3.0..1>   CSS: Clock Source Selection
 156              	//               <0=> Slow Clock
 157              	//               <1=> Main Clock
 158              	//               <2=> Reserved
 159              	//               <3=> PLL Clock
 160              	//   <o3.2..4>   PRES: Prescaler
 161              	//               <0=> None
 162              	//               <1=> Clock / 2    <2=> Clock / 4
 163              	//               <3=> Clock / 8    <4=> Clock / 16
 164              	//               <5=> Clock / 32   <6=> Clock / 64
 165              	//               <7=> Reserved
 166              	// </e>
 167              	*/
 168              	        .equ    PMC_SETUP,      1
 169              	        .equ    PMC_MOR_Val,    0x00000601
 170              	        .equ    PMC_PLLR_Val,   0x00191C05
 171              	        .equ    PMC_MCKR_Val,   0x00000007
 172              	
 173              	
 174              	
 175              	
 176              	#if defined(VECTORS_IN_RAM) && defined(ROM_RUN)
 177              	
 178              	/* 
 179              	 Exception Vectors to be placed in RAM - added by mt
 180              	 -> will be used after remapping in ROM_RUN
 181              	 -> not needed for RAM_RUN
 182              	 Mapped to Address 0 after remapping in ROM_RUN
 183              	 Absolute addressing mode must be used.
 184              	 Dummy Handlers are implemented as infinite loops which can be modified.
 185              	 VECTORS_IN_RAM defined in makefile/by commandline 
 186              	*/
 187              				.text
 188              				.arm
 189              				.section .vectram, "ax"
 190              				
 191 0000 18F09FE5 	VectorsRAM:     LDR     PC,Reset_AddrR
 192 0004 18F09FE5 	                LDR     PC,Undef_AddrR
 193 0008 18F09FE5 	                LDR     PC,SWI_AddrR
 194 000c 18F09FE5 	                LDR     PC,PAbt_AddrR
 195 0010 18F09FE5 	                LDR     PC,DAbt_AddrR
 196 0014 0000A0E1 	                NOP                            /* Reserved Vector */
 197 0018 20FF1FE5 	                LDR     PC,[PC,#-0xF20]        /* Vector From AIC_IVR */
 198 001c 20FF1FE5 	                LDR     PC,[PC,#-0xF20]        /* Vector From AIC_FVR */
 199              	
 200 0020 04000000 	Reset_AddrR:     .word   Reset_Handler
 201 0024 40000000 	Undef_AddrR:     .word   Undef_HandlerR
 202              	// SWI_AddrR:       .word   SWI_HandlerR
 203 0028 00000000 	SWI_AddrR:       .word   SWI_Handler @@R
 204 002c 48000000 	PAbt_AddrR:      .word   PAbt_HandlerR
 205 0030 4C000000 	DAbt_AddrR:      .word   DAbt_HandlerR
 206              	//               .word   0xdeadbeef     /* Test Reserved Address */
 207 0034 00000000 	                 .word   0     /* Reserved Address */
 208 0038 50000000 	IRQ_AddrR:       .word   IRQ_HandlerR
 209 003c 54000000 	FIQ_AddrR:       .word   FIQ_HandlerR
 210              	
 211 0040 0E0000EA 	Undef_HandlerR:  B       Undef_HandlerR
 212 0044 0F0000EA 	SWI_HandlerR:    B       SWI_HandlerR
 213 0048 100000EA 	PAbt_HandlerR:   B       PAbt_HandlerR
 214 004c 110000EA 	DAbt_HandlerR:   B       DAbt_HandlerR
 215 0050 120000EA 	IRQ_HandlerR:    B       IRQ_HandlerR
 216 0054 130000EA 	FIQ_HandlerR:    B       FIQ_HandlerR
 217              	
 218              	#endif /* VECTORS_IN_RAM && ROM_RUN */
 219              	
 220              	
 221              	
 222              	/*****************************************************************************
 223              	  Exception Vectors
 224              	
 225              	   - for ROM_RUN: placed in 0x00000000 
 226              	   - for RAM_RUN: placed at 0x00200000 (on AT91SAM7S64)
 227              	   -> will be used during startup before remapping with target ROM_RUN
 228              	   -> will be used "always" in code without remapping or with target RAM_RUN
 229              	   Mapped to Address relative address 0 of .text
 230              	   Absolute addressing mode must be used.
 231              	   Dummy Handlers are implemented as infinite loops which can be modified.
 232              	 *****************************************************************************/
 233              				.text
 234              				.arm
 235              				.section .vectrom, "ax"
 236              	
 237 0000 18F09FE5 	Vectors:        LDR     PC,Reset_Addr         
 238 0004 18F09FE5 	                LDR     PC,Undef_Addr
 239 0008 18F09FE5 	                LDR     PC,SWI_Addr
 240 000c 18F09FE5 	                LDR     PC,PAbt_Addr
 241 0010 18F09FE5 	                LDR     PC,DAbt_Addr
 242 0014 0000A0E1 	                NOP                            /* Reserved Vector */
 243              	//                LDR     PC,IRQ_Addr
 244 0018 20FF1FE5 	                LDR     PC,[PC,#-0xF20]        /* Vector From AIC_IVR */
 245              	//                LDR     PC,FIQ_Addr
 246 001c 20FF1FE5 	                LDR     PC,[PC,#-0xF20]        /* Vector From AIC_FVR */
 247              	
 248 0020 04000000 	Reset_Addr:     .word   Reset_Handler
 249 0024 00000000 	Undef_Addr:     .word   Undef_Handler
 250 0028 00000000 	SWI_Addr:       .word   SWI_Handler
 251 002c 00000000 	PAbt_Addr:      .word   PAbt_Handler
 252 0030 00000000 	DAbt_Addr:      .word   DAbt_Handler
 253 0034 00000000 	                .word   0                      /* Reserved Address */
 254 0038 00000000 	IRQ_Addr:       .word   IRQ_Handler
 255 003c 00000000 	FIQ_Addr:       .word   FIQ_Handler
 256              	
 257              	
 258              	/******************************************************************************
 259              	  Default exception handlers
 260              	  (These are declared weak symbols so they can be redefined in user code)
 261              	 ******************************************************************************/
 262 0040 FEFFFFEA 	Undef_Handler:  B       Undef_Handler
 263 0044 FEFFFFEA 	SWI_Handler:    B       SWI_Handler
 264 0048 FEFFFFEA 	PAbt_Handler:   B       PAbt_Handler
 265 004c FEFFFFEA 	DAbt_Handler:   B       DAbt_Handler
 266 0050 FEFFFFEA 	IRQ_Handler:    B       IRQ_Handler
 267 0054 FEFFFFEA 	FIQ_Handler:    B       FIQ_Handler
 268              	
 269              	.weak Undef_Handler, SWI_Handler, PAbt_Handler, DAbt_Handler, IRQ_Handler, FIQ_Handler
 270              	
 271              	// Starupt Code must be linked first at Address at which it expects to run.
 272              	
 273              			.text
 274              			.arm
 275              			.section .init, "ax"
 276              		
 277              			.global _startup
 278              			.func   _startup
 279              	_startup:
 280              	
 281              	
 282              	// Reset Handler
 283 0000 20F19FE5 	                LDR     pc, =Reset_Handler
 284              	Reset_Handler:
 285              	
 286              	// Setup EFC
 287              	.if EFC_SETUP
 288 0004 FF00E0E3 	                LDR     R0, =EFC_BASE
 289 0008 1C119FE5 	                LDR     R1, =EFC_FMR_Val
 290 000c 601080E5 	                STR     R1, [R0, #EFC_FMR]
 291              	.endif
 292              	
 293              	
 294              	// Setup WDT
 295              	.if WDT_SETUP
 296 0010 18019FE5 	                LDR     R0, =WDT_BASE
 297 0014 0219A0E3 	                LDR     R1, =WDT_MR_Val
 298 0018 041080E5 	                STR     R1, [R0, #WDT_MR]
 299              	.endif
 300              	
 301              	
 302              	// Setup PMC
 303              	.if PMC_SETUP
 304 001c 10019FE5 	                LDR     R0, =PMC_BASE
 305              	
 306              	//  Setup Main Oscillator
 307 0020 10119FE5 	                LDR     R1, =PMC_MOR_Val
 308 0024 201080E5 	                STR     R1, [R0, #PMC_MOR]
 309              	
 310              	//  Wait until Main Oscillator is stablilized
 311              	.if (PMC_MOR_Val & PMC_MOSCEN)
 312 0028 682090E5 	MOSCS_Loop:     LDR     R2, [R0, #PMC_SR]
 313 002c 012012E2 	                ANDS    R2, R2, #PMC_MOSCS
 314 0030 0800000A 	                BEQ     MOSCS_Loop
 315              	.endif
 316              	
 317              	//  Setup the PLL
 318              	.if (PMC_PLLR_Val & PMC_MUL)
 319 0034 00119FE5 	                LDR     R1, =PMC_PLLR_Val
 320 0038 2C1080E5 	                STR     R1, [R0, #PMC_PLLR]
 321              	
 322              	//  Wait until PLL is stabilized
 323 003c 682090E5 	PLL_Loop:       LDR     R2, [R0, #PMC_SR]
 324 0040 042012E2 	                ANDS    R2, R2, #PMC_LOCK
 325 0044 0D00000A 	                BEQ     PLL_Loop
 326              	.endif
 327              	
 328              	//  Select Clock
 329 0048 0710A0E3 	                LDR     R1, =PMC_MCKR_Val
 330 004c 301080E5 	                STR     R1, [R0, #PMC_MCKR]
 331              	.endif
 332              	
 333              	
 334              	// Setup Stack for each mode
 335              	
 336 0050 8109A0E3 	                LDR     R0, =Top_Stack
 337              	
 338              	//  Enter Undefined Instruction Mode and set its Stack Pointer
 339 0054 DBF021E3 	                MSR     CPSR_c, #Mode_UND|I_Bit|F_Bit
 340 0058 00D0A0E1 	                MOV     SP, R0
 341 005c 040040E2 	                SUB     R0, R0, #UND_Stack_Size
 342              	
 343              	//  Enter Abort Mode and set its Stack Pointer
 344 0060 D7F021E3 	                MSR     CPSR_c, #Mode_ABT|I_Bit|F_Bit
 345 0064 00D0A0E1 	                MOV     SP, R0
 346 0068 040040E2 	                SUB     R0, R0, #ABT_Stack_Size
 347              	
 348              	//  Enter FIQ Mode and set its Stack Pointer
 349 006c D1F021E3 	                MSR     CPSR_c, #Mode_FIQ|I_Bit|F_Bit
 350 0070 00D0A0E1 	                MOV     SP, R0
 351 0074 040040E2 	                SUB     R0, R0, #FIQ_Stack_Size
 352              	
 353              	//  Enter IRQ Mode and set its Stack Pointer
 354 0078 D2F021E3 	                MSR     CPSR_c, #Mode_IRQ|I_Bit|F_Bit
 355 007c 00D0A0E1 	                MOV     SP, R0
 356 0080 010C40E2 	                SUB     R0, R0, #IRQ_Stack_Size
 357              	
 358              	//  Enter Supervisor Mode and set its Stack Pointer
 359 0084 D3F021E3 	                MSR     CPSR_c, #Mode_SVC|I_Bit|F_Bit
 360 0088 00D0A0E1 	                MOV     SP, R0
 361 008c 010C40E2 	                SUB     R0, R0, #SVC_Stack_Size
 362              	
 363              	//  Enter System Mode and set its Stack Pointer
 364 0090 DFF021E3 	                MSR     CPSR_c, #Mode_SYS|I_Bit|F_Bit
 365 0094 00D0A0E1 	                MOV     SP, R0
 366              	
 367              	////  Enter User Mode and set its Stack Pointer
 368              	//                MSR     CPSR_c, #Mode_USR
 369              	//                MOV     SP, R0
 370              	//
 371              	//// Setup a default Stack Limit (when compiled with "-mapcs-stack-check")
 372              	//                SUB     SL, SP, #USR_Stack_Size
 373              	
 374              	// We want to start in supervisor mode.  Operation will switch to system
 375              	// mode when the first task starts.
 376 0098 D3F021E3 	                MSR     CPSR_c, #Mode_SVC|I_Bit|F_Bit
 377              	
 378              	
 379              	#ifdef ROM_RUN
 380              	// Relocate .data section (Copy from ROM to RAM)
 381 009c 9C109FE5 	                LDR     R1, =_etext
 382 00a0 9C209FE5 	                LDR     R2, =_data
 383 00a4 9C309FE5 	                LDR     R3, =_edata
 384 00a8 030052E1 	LoopRel:        CMP     R2, R3
 385 00ac 04009134 	                LDRLO   R0, [R1], #4
 386 00b0 04008234 	                STRLO   R0, [R2], #4
 387 00b4 2800003A 	                BLO     LoopRel
 388              	#endif
 389              	
 390              	// Clear .bss section (Zero init)
 391 00b8 0000A0E3 	                MOV     R0, #0
 392 00bc 88109FE5 	                LDR     R1, =__bss_start__
 393 00c0 88209FE5 	                LDR     R2, =__bss_end__
 394 00c4 020051E1 	LoopZI:         CMP     R1, R2
 395 00c8 04008134 	                STRLO   R0, [R1], #4
 396 00cc 2F00003A 	                BLO     LoopZI
 397              	
 398              	
 399              	#if defined(VECTORS_IN_RAM) || defined(RAM_RUN)
 400              	/* 
 401              	   *** Remap ***
 402              	   ROM_RUN: exception vectors for RAM have been already copied 
 403              	     to 0x00200000 by the .data copy-loop 
 404              	   RAM_RUN: exception vectors are already placed at 0x0020000 by
 405              	     linker settings
 406              	*/
 407              					.equ    MC_BASE,0xFFFFFF00  /* MC Base Address */
 408              					.equ    MC_RCR, 0x00        /* MC_RCR Offset */
 409              	
 410 00d0 FF00E0E3 					LDR     R0, =MC_BASE
 411 00d4 0110A0E3 					MOV     R1, #1
 412 00d8 001080E5 					STR     R1, [R0, #MC_RCR]   // Remap
 413              	#endif /* VECTORS_IN_RAM || RAM_RUN */
 414              	
 415              	
 416              	/*
 417              	   Call C++ constructors (for objects in "global scope")
 418              	   added by Martin Thomas based on a Anglia Design 
 419              	   example-application for STR7 ARM
 420              	*/
 421              	
 422 00dc 70009FE5 				LDR 	r0, =__ctors_start__
 423 00e0 70109FE5 				LDR 	r1, =__ctors_end__
 424              	ctor_loop:
 425 00e4 010050E1 				CMP 	r0, r1
 426 00e8 3F00000A 				BEQ 	ctor_end
 427 00ec 042090E4 				LDR 	r2, [r0], #4   /* this ctor's address */
 428 00f0 03002DE9 				STMFD 	sp!, {r0-r1}   /* save loop counters  */
 429 00f4 0FE0A0E1 				MOV 	lr, pc         /* set return address  */
 430              	//			MOV 	pc, r2
 431 00f8 12FF2FE1 				BX      r2             /* call ctor */
 432 00fc 0300BDE8 				LDMFD 	sp!, {r0-r1}   /* restore loop counters */
 433 0100 370000EA 				B 		ctor_loop
 434              	ctor_end:
 435              	
 436              	       
 437              	// Enter the C code
 438 0104 0000A0E3 					mov   r0,#0            // no arguments (argc = 0)
 439 0108 0010A0E1 					mov   r1,r0
 440 010c 0020A0E1 					mov   r2,r0
 441 0110 00B0A0E1 					mov   fp,r0            // null frame pointer
 442 0114 0070A0E1 					mov   r7,r0            // null frame pointer for thumb
 443 0118 3CA09FE5 					ldr   r10,=main
 444 011c 00E08FE2 					adr   lr, __main_exit
 445 0120 1AFF2FE1 					bx    r10              // enter main()
 446              	
 447 0124 470000EA 	__main_exit:    B       __main_exit
 448              	
 449              	
 451              					.endfunc
 452              	
 453 0128 04000000 	.end
 453      00013200 
 453      40FDFFFF 
 453      00FCFFFF 
 453      01060000 
DEFINED SYMBOLS
                            *ABS*:00000000 startup_SAM7S.S
     startup_SAM7S.S:38     *ABS*:00000010 Mode_USR
     startup_SAM7S.S:39     *ABS*:00000011 Mode_FIQ
     startup_SAM7S.S:40     *ABS*:00000012 Mode_IRQ
     startup_SAM7S.S:41     *ABS*:00000013 Mode_SVC
     startup_SAM7S.S:42     *ABS*:00000017 Mode_ABT
     startup_SAM7S.S:43     *ABS*:0000001b Mode_UND
     startup_SAM7S.S:44     *ABS*:0000001f Mode_SYS
     startup_SAM7S.S:46     *ABS*:00000080 I_Bit
     startup_SAM7S.S:47     *ABS*:00000040 F_Bit
     startup_SAM7S.S:51     *ABS*:00100000 FLASH_BASE
     startup_SAM7S.S:52     *ABS*:00200000 RAM_BASE
     startup_SAM7S.S:68     *ABS*:00204000 Top_Stack
     startup_SAM7S.S:70     *ABS*:00000004 UND_Stack_Size
     startup_SAM7S.S:71     *ABS*:00000100 SVC_Stack_Size
     startup_SAM7S.S:72     *ABS*:00000004 ABT_Stack_Size
     startup_SAM7S.S:73     *ABS*:00000004 FIQ_Stack_Size
     startup_SAM7S.S:74     *ABS*:00000100 IRQ_Stack_Size
     startup_SAM7S.S:75     *ABS*:00000400 USR_Stack_Size
     startup_SAM7S.S:79     *ABS*:ffffff00 EFC_BASE
     startup_SAM7S.S:80     *ABS*:00000060 EFC_FMR
     startup_SAM7S.S:93     *ABS*:00000001 EFC_SETUP
     startup_SAM7S.S:94     *ABS*:00320100 EFC_FMR_Val
     startup_SAM7S.S:98     *ABS*:fffffd40 WDT_BASE
     startup_SAM7S.S:99     *ABS*:00000004 WDT_MR
     startup_SAM7S.S:113    *ABS*:00000001 WDT_SETUP
     startup_SAM7S.S:114    *ABS*:00008000 WDT_MR_Val
     startup_SAM7S.S:118    *ABS*:fffffc00 PMC_BASE
     startup_SAM7S.S:119    *ABS*:00000020 PMC_MOR
     startup_SAM7S.S:120    *ABS*:00000024 PMC_MCFR
     startup_SAM7S.S:121    *ABS*:0000002c PMC_PLLR
     startup_SAM7S.S:122    *ABS*:00000030 PMC_MCKR
     startup_SAM7S.S:123    *ABS*:00000068 PMC_SR
     startup_SAM7S.S:124    *ABS*:00000001 PMC_MOSCEN
     startup_SAM7S.S:125    *ABS*:00000002 PMC_OSCBYPASS
     startup_SAM7S.S:126    *ABS*:0000ff00 PMC_OSCOUNT
     startup_SAM7S.S:127    *ABS*:000000ff PMC_DIV
     startup_SAM7S.S:128    *ABS*:00003f00 PMC_PLLCOUNT
     startup_SAM7S.S:129    *ABS*:0000c000 PMC_OUT
     startup_SAM7S.S:130    *ABS*:07ff0000 PMC_MUL
     startup_SAM7S.S:131    *ABS*:30000000 PMC_USBDIV
     startup_SAM7S.S:132    *ABS*:00000003 PMC_CSS
     startup_SAM7S.S:133    *ABS*:0000001c PMC_PRES
     startup_SAM7S.S:134    *ABS*:00000001 PMC_MOSCS
     startup_SAM7S.S:135    *ABS*:00000004 PMC_LOCK
     startup_SAM7S.S:168    *ABS*:00000001 PMC_SETUP
     startup_SAM7S.S:169    *ABS*:00000601 PMC_MOR_Val
     startup_SAM7S.S:170    *ABS*:00191c05 PMC_PLLR_Val
     startup_SAM7S.S:171    *ABS*:00000007 PMC_MCKR_Val
     startup_SAM7S.S:188    .text:00000000 $a
     startup_SAM7S.S:191    .vectram:00000000 VectorsRAM
     startup_SAM7S.S:191    .vectram:00000000 $a
     startup_SAM7S.S:200    .vectram:00000020 Reset_AddrR
     startup_SAM7S.S:201    .vectram:00000024 Undef_AddrR
     startup_SAM7S.S:203    .vectram:00000028 SWI_AddrR
     startup_SAM7S.S:204    .vectram:0000002c PAbt_AddrR
     startup_SAM7S.S:205    .vectram:00000030 DAbt_AddrR
     startup_SAM7S.S:200    .vectram:00000020 $d
     startup_SAM7S.S:284    .init:00000004 Reset_Handler
     startup_SAM7S.S:211    .vectram:00000040 Undef_HandlerR
     startup_SAM7S.S:263    .vectrom:00000044 SWI_Handler
     startup_SAM7S.S:213    .vectram:00000048 PAbt_HandlerR
     startup_SAM7S.S:214    .vectram:0000004c DAbt_HandlerR
     startup_SAM7S.S:208    .vectram:00000038 IRQ_AddrR
     startup_SAM7S.S:215    .vectram:00000050 IRQ_HandlerR
     startup_SAM7S.S:209    .vectram:0000003c FIQ_AddrR
     startup_SAM7S.S:216    .vectram:00000054 FIQ_HandlerR
     startup_SAM7S.S:211    .vectram:00000040 $a
     startup_SAM7S.S:212    .vectram:00000044 SWI_HandlerR
     startup_SAM7S.S:237    .vectrom:00000000 Vectors
     startup_SAM7S.S:237    .vectrom:00000000 $a
     startup_SAM7S.S:248    .vectrom:00000020 Reset_Addr
     startup_SAM7S.S:249    .vectrom:00000024 Undef_Addr
     startup_SAM7S.S:250    .vectrom:00000028 SWI_Addr
     startup_SAM7S.S:251    .vectrom:0000002c PAbt_Addr
     startup_SAM7S.S:252    .vectrom:00000030 DAbt_Addr
     startup_SAM7S.S:248    .vectrom:00000020 $d
     startup_SAM7S.S:262    .vectrom:00000040 Undef_Handler
     startup_SAM7S.S:264    .vectrom:00000048 PAbt_Handler
     startup_SAM7S.S:265    .vectrom:0000004c DAbt_Handler
     startup_SAM7S.S:254    .vectrom:00000038 IRQ_Addr
     startup_SAM7S.S:266    .vectrom:00000050 IRQ_Handler
     startup_SAM7S.S:255    .vectrom:0000003c FIQ_Addr
     startup_SAM7S.S:267    .vectrom:00000054 FIQ_Handler
     startup_SAM7S.S:262    .vectrom:00000040 $a
     startup_SAM7S.S:279    .init:00000000 _startup
     startup_SAM7S.S:283    .init:00000000 $a
     startup_SAM7S.S:312    .init:00000028 MOSCS_Loop
     startup_SAM7S.S:323    .init:0000003c PLL_Loop
     startup_SAM7S.S:384    .init:000000a8 LoopRel
     startup_SAM7S.S:394    .init:000000c4 LoopZI
     startup_SAM7S.S:407    *ABS*:ffffff00 MC_BASE
     startup_SAM7S.S:408    *ABS*:00000000 MC_RCR
     startup_SAM7S.S:424    .init:000000e4 ctor_loop
     startup_SAM7S.S:434    .init:00000104 ctor_end
     startup_SAM7S.S:447    .init:00000124 __main_exit
     startup_SAM7S.S:453    .init:00000128 $d

UNDEFINED SYMBOLS
_etext
_data
_edata
__bss_start__
__bss_end__
__ctors_start__
__ctors_end__
main
